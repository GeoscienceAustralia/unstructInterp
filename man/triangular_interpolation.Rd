% Generated by roxygen2 (4.0.1): do not edit by hand
\name{triangular_interpolation}
\alias{triangular_interpolation}
\title{Function for various types of triangular ['linear'] interpolation of unstructured data.}
\usage{
triangular_interpolation(xy, vals, newPts, useNearestNeighbour = TRUE)
}
\arguments{
\item{xy}{= points (typically nx2 matrix)}

\item{vals}{= values at xy (can be a matix with 1 or more colums)}

\item{newPts}{= points where we want interpolated values (typically nx2 matrix)}

\item{useNeaestNeighbour}{= TRUE/FALSE (effect described above)}
}
\value{
matrix/vector with as many columns as 'vals' and as many rows as 'newPts', containing the 'vals' interpolated to 'newPts'
}
\description{
If useNearestNeighbour = FALSE then it provides a wrapper around the delanay triangulation used in the 'geometry' package.
Unfortunately the look-up can be slow with this method for large point clouds.
If useNearestNeighbour=TRUE, we find the 3 nearest xy neighbours of each point to interpolate to, and
interpolate using the plane defined by those 3 neighbours. Limiting is used
to ensure the interpolated value does not exceed the range of the xy
neighbours. This method is fast since it relies only an a fast nearest neighbours implementation (via SearchTrees)
}
\examples{
# Make a single triangle in the plane z=x+y, and interpolate from it
   xy=matrix(c(0,0,0,1,1,1),ncol=2,byrow=TRUE)
   vals=c(0, 1, 2) # z=x+y
   newPts=matrix(c(0.5, 0.5, 0.3, 0.3), ncol=2, byrow=TRUE)

   out=triangular_interpolation(xy, vals, newPts)
   stopifnot(all.equal(out, c(1.0,0.6)))

   # Re-order triangle
   xy=xy[3:1,]
   vals=vals[3:1]
   out=triangular_interpolation(xy, vals, newPts)
   stopifnot(all.equal(out,c(1.0,0.6)))

   #another one, with formula z=0.5*x+0.2*y+7
   xy=matrix(c(-1, -1, 1, -0.5, 0.5, 1), ncol=2,byrow=2)
   vals=0.5*xy[,1]+0.2*xy[,2]+7
   newPts=matrix(c(0,0, 0.5, 0.3),ncol=2,byrow=TRUE)
   expectedVals=0.5*newPts[,1]+0.2*newPts[,2]+7
   out=triangular_interpolation(xy,vals,newPts)
   stopifnot(all.equal(out,expectedVals))

   # A point outside the triangle
   newPts=matrix(c(-1,0, -1, 1),ncol=2,byrow=TRUE)
   out=triangular_interpolation(xy,vals,newPts,useNearestNeighbour=FALSE)
   stopifnot(all(is.na(out))| formals(triangular_interpolation)$useNearestNeighbour)
   # Failure is expected here if using approximate triangulation based on nearest neighbour methods

   # A single point
   newPts=matrix(c(0,0),ncol=2)
   out=triangular_interpolation(xy,vals,newPts)
   stopifnot(out==7)

   # Points on the triangle
   newPts=xy
   out=triangular_interpolation(xy,vals,newPts)
   stopifnot(all(out==vals))

   # Point on an edge
   newPts=matrix(0.5*(xy[1,]+xy[2,]),ncol=2)
   out=triangular_interpolation(xy,vals,newPts)
   stopifnot(all(out==0.5*(vals[1]+vals[2])))
}

